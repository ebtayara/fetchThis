Phase: git project flow
    git checkout -b <<branch-name>>
    git checkout main
    git pull
    git checkout <<branch-name>>
    git merge main

Phase 0:
-[x] Install the project's dependencies (npm install); and
    -[x] npm install
    -[x] npm uninstall pg
    -[x] npm install pg
    -[x] npm install express@^4.0.0 pug@^2.0.0
    -[x] npm install nodemon@^2.0.0 --save-dev
    -[x] npm install dotenv dotenv-cli --save-dev
    -[x] npm install per-env
    -[x] npm install csurf@^1.0.0
    -[x] npm install cookie-parser@^1.0.0
    -[x] npm install express-validator@^6.0.0
    -[x] npm install morgan
    -[x] npm install sequelize-cli@^5.0.0 --save-dev
    -[x] #!/usr/bin/env node     and then   bin/www  but it didn't work so NPM START
    -[] npm install bcryptjs
-[x] touch.env
    PORT=8080
    DB_USERNAME=fetchThisAdmin
    DB_PASSWORD=fetchThisPassword
    DB_DATABASE=fetchThisDb
    DB_HOST=localhost
    SESSION_SECRET=fetchThisSecret
-[x] Add an .env file containing the variables from the .env.example file;
    touch .env
-[x] Create the database and limited access database user;
    CREATE USER fetchThisAdmin WITH PASSWORD 'fetchThisPassword' CREATEDB;
-[x] Use the Sequelize CLI to apply the provided database migrations and seeder.
    npx dotenv sequelize-cli db:create

-[x] Now you can start (npm start) and test the application!
    npm start

        npx dotenv sequelize db:seed:undo:all
        npx dotenv sequelize db:migrate:undo:all
        npx dotenv sequelize db:drop fetchThisDb
        npx dotenv sequelize db:migrate
        npx dotenv sequelize db:seed:all
-[x]
npx sequelize-cli model:generate --name User --attributes username:string,hashedPassword:string,email:string
npx sequelize-cli model:generate --name List --attributes name:string,userId:integer
npx sequelize-cli model:generate --name Task --attributes name:string,description:string,userId:integer,listId:integer,completed:boolean

-[x] npx dotenv sequelize-cli db:migrate
-[x] npx sequelize-cli seed:generate --name fetchThisUserData
-[x] npx sequelize-cli seed:generate --name fetchThisTaskData
-[x] npx sequelize-cli seed:generate --name fetchThisListData


### Phase 2: Configure Express to use sessions ###
-[x] touch auth.js
-[x] npm install express-session
-[x] app. js > const session = require('express-session');
-[x] generate a UUID to have a more secure sessionSecret variable value.
    `fetchThisSecret`
-[x] set a SESSION_SECRET environment variable in your .env file.
    SESSION_SECRET=fetchThisSecret
-[x] update .env
-[x] Add a key of sessionSecret connected to the process.env.SESSION_SECRET in your ./config/index.js
./config/index.js
```
module.exports = {
  environment: process.env.NODE_ENV || 'development',
  port: process.env.PORT || 8080,
  sessionSecret: process.env.SESSION_SECRET,
  db: {
    username: process.env.DB_USERNAME,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_DATABASE,
    host: process.env.DB_HOST,
  },
};
```

-[x] app module import the sessionSecret in your ./config require statement
    const session = require('express-session');
    const { sessionSecret } = require('./config');

-[x] touch utils.js

Phase: Creating a user login

router.get('/login', csrfProtection, (req, res) => {
  res.render('userLogin', {
    title: 'Login',
    csrfToken: req.csrfToken(),
  });
});

const loginValidators = [
  check('email')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Email Address'),
  check('hashedPassword')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Password'),
];

router.post('/login', csrfProtection
  asyncHandler(async (req, res) => {
    const {
      email,
      hashedPassword,
    } = req.body;

    let errors = [];
    const validatorErrors = validationResult(req);

    if (validatorErrors.isEmpty()) {
      // TODO Attempt to login the user.
    } else {
      errors = validatorErrors.array().map((error) => error.msg);
    }
    res.render('userLogin', {
      title: 'Login',
      email,
      csrfToken: req.csrfToken(),
    });
  }));


Persistance User is being stored in a cookie
Restoring User is stored in Database

We are starting at:

```
router.get('/user/register', csrfProtection, (req, res) => {
  const user = db.User.build();
  res.render('user-register', {
    title: 'Register',
    user,
    csrfToken: req.csrfToken(),
  });
});

const userValidators = [
  check('firstName')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for First Name')
    .isLength({ max: 50 })
    .withMessage('First Name must not be more than 50 characters long'),
  check('lastName')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Last Name')
    .isLength({ max: 50 })
    .withMessage('Last Name must not be more than 50 characters long'),
  check('emailAddress')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Email Address')
    .isLength({ max: 255 })
    .withMessage('Email Address must not be more than 255 characters long')
    .isEmail()
    .withMessage('Email Address is not a valid email')
    .custom((value) => {
      return db.User.findOne({ where: { emailAddress: value } })
        .then((user) => {
          if (user) {
            return Promise.reject('The provided Email Address is already in use by another account');
          }
        });
    }),
  check('password')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Password')
    .isLength({ max: 50 })
    .withMessage('Password must not be more than 50 characters long')
    .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*[0-9])(?=.*[!@#$%^&*])/, 'g')
    .withMessage('Password must contain at least 1 lowercase letter, uppercase letter, number, and special character (i.e. "!@#$%^&*")'),
  check('confirmPassword')
    .exists({ checkFalsy: true })
    .withMessage('Please provide a value for Confirm Password')
    .isLength({ max: 50 })
    .withMessage('Confirm Password must not be more than 50 characters long')
    .custom((value, { req }) => {
      if (value !== req.body.password) {
        throw new Error('Confirm Password does not match Password');
      }
      return true;
    }),
];

router.post('/user/register', csrfProtection, userValidators,
  asyncHandler(async (req, res) => {
    const {
      emailAddress,
      firstName,
      lastName,
      password,
    } = req.body;

    const user = db.User.build({
      emailAddress,
      firstName,
      lastName,
    });

    const validatorErrors = validationResult(req);

    if (validatorErrors.isEmpty()) {
      const hashedPassword = await bcrypt.hash(password, 10);
      user.hashedPassword = hashedPassword;
      await user.save();
      loginUser(req, res, user);
      res.redirect('/');
    } else {
      const errors = validatorErrors.array().map((error) => error.msg);
      res.render('user-register', {
        title: 'Register',
        user,
        errors,
        csrfToken: req.csrfToken(),
      });
    }
  }));


```

Phase:
